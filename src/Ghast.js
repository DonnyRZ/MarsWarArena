// --- START OF FILE Ghast.js ---
import * as THREE from 'three';
import { MathUtils } from 'three/src/math/MathUtils.js';
import { GhastMovement } from './GhastMovement.js';
import { Fireball } from './Fireball.js';

export class Ghast {
    // constructor(scene, position, world, territoryBounds) { // OLD Signature
    constructor(scene, position, world, territoryBounds, entityManager) { // <<<--- NEW Signature: Add entityManager
        if (!scene || !position || !world) { console.error("Ghast constructor missing required arguments:", { scene, position, world }); throw new Error("Ghast constructor requires scene, position, and world."); }
        if (!territoryBounds || territoryBounds.minX === undefined) { console.error("Ghast constructor missing valid territoryBounds:", territoryBounds); throw new Error("Ghast constructor requires valid territoryBounds object."); }
        if (!entityManager) { console.error("Ghast constructor missing entityManager argument."); throw new Error("Ghast constructor requires entityManager."); } // <<<--- Add check

        this.scene = scene;
        this.world = world;
        this.entityManager = entityManager; // <<<--- Store entityManager reference
        this.position = position.clone();
        this.visualPosition = this.position.clone();
        this.health = 1000;
        this.isDead = false;
        this.clock = new THREE.Clock();

        // Attack Parameters
        this.attackRange = 35.0;
        this.attackRangeSq = this.attackRange * this.attackRange;
        this.fireballCooldown = 2.5;
        this.fireballSpeed = 18.0;
        this.fireballLifetime = 4.0;
        this.fireballDamage = 30;
        this.attackCooldownTimer = Math.random() * this.fireballCooldown;
        this.currentTarget = null;
        this.isAttackingOrCoolingDown = false;

        // Animation state helpers
        this.twitchTimer = 0;
        this.twitchDuration = 0.08 + Math.random() * 0.1;
        this.timeUntilTwitch = 0.5 + Math.random() * 1.0;
        this.twitchOffset = new THREE.Vector3();
        this.twitchRotOffset = new THREE.Euler();
        this.pulsatingMaterials = [];
        this.particleSources = [];
        this.particles = null;
        this.particleGeometry = null;
        this.particleLifetimes = [];
        this.particleVelocities = [];
        this.particlesToSpawn = 0;
        this.fireballGroup = null;
        this.bodyYOffset = 0;

        // Movement Controller
        this.movementController = new GhastMovement(this, world, territoryBounds);

        this.mesh = new THREE.Group();
        this.mesh.name = "GhastCreature_Scary";

        // Collision Cylinder Properties
        this.cylinderRadius = 8;
        this.cylinderHeight = 20;
        this.showCollisionCylinder = false;
        this.collisionCylinderMesh = null;

        this.buildCreature();
        const desiredScale = 0.6;
        this.mesh.scale.set(desiredScale, desiredScale, desiredScale);
        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);
        // console.log("Aggressive Ghast spawned at:", this.position, "with scale:", desiredScale); // Reduce logging
    }

    buildCreature() {
        // ... (buildCreature logic remains exactly the same as before) ...
        const BASE_COLOR = 0x1a1a1a; const NOISE_COLORS_BODY = [0x0a0a0a, 0x111111, 0x151515]; const NOISE_LIGHT_BODY = 0x252525; const NOISE_LARGE_BODY = 0x303030; const MOUTH_BG_COLOR = 0x000000; const HORN_COLOR = 0x151515; const HORN_NOISE_VARIANTS = [0x050505, 0x0a0a0a, 0x0f0f0f]; const HORN_NOISE_LIGHT = 0x1f1f1f; const TENTACLE_COLOR_BASE = 0x222222; const TENTACLE_NOISE_VARIANTS = [0x121212, 0x181818, 0x1e1e1e]; const TENTACLE_NOISE_LIGHT = 0x333333; const TENTACLE_TIP_COLOR = 0x0a0a0a; const EMISSIVE_COLOR = 0xffffff; const SIGIL_EMISSIVE_INTENSITY_BASE = 1.5; const HORN_SIGIL_EMISSIVE_INTENSITY_BASE = 1.0; const BUMP_SCALE = 0.02; const TEXTURE_RESOLUTION = 256; const sf = TEXTURE_RESOLUTION / 16; const BODY_SIZE = 9; const TENTACLE_WIDTH = 1.8; const TENTACLE_HEIGHT = 7;
        const TENTACLE_SPACING = 2.5; const HORN_BASE_WIDTH = 2.2; const HORN_BASE_DEPTH = 2.2; const HORN_SEGMENT_HEIGHT = 0.6; const HORN_SEGMENTS = 12; const HORN_SPACING_X = 1.8; const HORN_TAPER = 0.91; const HORN_CURVE_ANGLE = Math.PI / 45; const HORN_TWIST_ANGLE = Math.PI / 96; const PARTICLE_COUNT = 250; const PARTICLE_SIZE = 0.10; const PARTICLE_LIFETIME = 1.1; const PARTICLE_INITIAL_VELOCITY = 1.4; const PARTICLE_DRAG = 0.97;
        const RED_GLOW_COLOR_HEX = 0xff0000; const FACE_CORE_BASE_COLOR_HEX = 0x330000; const HALO_SCALE = 1.35; const HALO_OPACITY = 0.55; const FACE_CORE_EMISSIVE_INTENSITY = 1.0;
        const FIREBALL_COUNT = 25; const FIREBALL_CORE_SIZE = 0.30; const FIREBALL_HALO_SIZE = 0.55; const FIREBALL_HALO_OPACITY = 0.7; const FIREBALL_COLOR = 0xff6600; const FIREBALL_CORE_EMISSIVE_INTENSITY = 1.0; const FIREBALL_ORBIT_RADIUS_MIN = BODY_SIZE * 0.7; const FIREBALL_ORBIT_RADIUS_MAX = BODY_SIZE * 1.1; const FIREBALL_ORBIT_SPEED_MIN = 0.8; const FIREBALL_ORBIT_SPEED_MAX = 1.4; const FIREBALL_VERTICAL_SPREAD = BODY_SIZE * 0.5; const FIREBALL_NOISE_AMOUNT = 0.8; const FIREBALL_NOISE_SPEED = 0.7; const FIREBALL_SYSTEM_ROTATION_SPEED = 0.3;
        function createHyperGhastTextures(width, height, bgColor, noiseParams = { countFine: 0, countLarge: 0, colorsFine: [], colorLightFine: 0xffffff, colorLarge: 0xffffff }, markings = [], eyes = [], sigils = [], gradientStrength = 0.05 ) { const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false; const emissiveCanvas = document.createElement('canvas'); emissiveCanvas.width = width; emissiveCanvas.height = height; const emissiveCtx = emissiveCanvas.getContext('2d'); emissiveCtx.imageSmoothingEnabled = false; emissiveCtx.fillStyle = '#000000'; emissiveCtx.fillRect(0, 0, width, height); const grad = ctx.createLinearGradient(0, 0, 0, height); const baseColorHex = `#${bgColor.toString(16).padStart(6, '0')}`; const gradColorTop = new THREE.Color(bgColor).lerp(new THREE.Color(0xffffff), gradientStrength).getHexString(); const gradColorBottom = new THREE.Color(bgColor).lerp(new THREE.Color(0x000000), gradientStrength).getHexString(); grad.addColorStop(0, `#${gradColorTop}`); grad.addColorStop(1, `#${gradColorBottom}`); ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height); if (noiseParams.countLarge > 0) { const largeDotSize = 8 * sf; ctx.fillStyle = `#${noiseParams.colorLarge.toString(16).padStart(6, '0')}1A`; for (let i = 0; i < noiseParams.countLarge; i++) { const x = Math.random() * (width - largeDotSize); const y = Math.random() * (height - largeDotSize); ctx.fillRect(x, y, largeDotSize, largeDotSize); } } if (noiseParams.countFine > 0 && noiseParams.colorsFine.length > 0) { const dotSizeW = 1 * sf; const dotSizeH = 1 * sf; const allNoiseColors = [...noiseParams.colorsFine, noiseParams.colorLightFine]; for (let i = 0; i < noiseParams.countFine * 4; i++) { const x = Math.random() * (width - dotSizeW); const y = Math.random() * (height - dotSizeH); const colorIndex = Math.floor(Math.random() * allNoiseColors.length); ctx.fillStyle = `#${allNoiseColors[colorIndex].toString(16).padStart(6, '0')}`; ctx.fillRect(x, y, dotSizeW, dotSizeH); } } const mouthBg = markings.find(m => m.isMouthBg); if (mouthBg) { ctx.fillStyle = `#${mouthBg.color.toString(16).padStart(6, '0')}`; ctx.fillRect(mouthBg.x, mouthBg.y, mouthBg.w, mouthBg.h); } markings.forEach(m => { if (!m.isMouthBg) { ctx.fillStyle = `#${m.color.toString(16).padStart(6, '0')}`; ctx.fillRect(m.x, m.y, m.w, m.h); } }); sigils.forEach(sigilPart => { ctx.fillStyle = `#${EMISSIVE_COLOR.toString(16).padStart(6, '0')}`; ctx.fillRect(sigilPart.x, sigilPart.y, sigilPart.w, sigilPart.h); emissiveCtx.fillStyle = '#ffffff'; emissiveCtx.fillRect(sigilPart.x, sigilPart.y, sigilPart.w, sigilPart.h); }); const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.LinearMipMapLinearFilter; texture.needsUpdate = true; texture.colorSpace = THREE.SRGBColorSpace; const emissiveTexture = new THREE.CanvasTexture(emissiveCanvas); emissiveTexture.magFilter = THREE.NearestFilter; emissiveTexture.minFilter = THREE.NearestFilter; emissiveTexture.colorSpace = THREE.SRGBColorSpace; return { texture, emissiveTexture }; }
        function createArcSigil(cx, cy, radius, startAngle, endAngle, segments, thickness) { const parts = []; const angleStep = (endAngle - startAngle) / segments; for (let i = 0; i <= segments; i++) { const angle = startAngle + i * angleStep; const x = cx + Math.cos(angle) * radius; const y = cy + Math.sin(angle) * radius; parts.push({ x: x - (thickness/2)*sf, y: y - (thickness/2)*sf, w: thickness*sf, h: thickness*sf }); } return parts; }
        function createLineSigil(x1, y1, x2, y2, segments, thickness) { const parts = []; const dx = (x2 - x1) / segments; const dy = (y2 - y1) / segments; for (let i = 0; i <= segments; i++) { const x = x1 + i * dx; const y = y1 + i * dy; parts.push({ x: x - (thickness/2)*sf, y: y - (thickness/2)*sf, w: thickness*sf, h: thickness*sf }); } return parts; }
        const bodyNoiseParams = { countFine: 800, countLarge: 70, colorsFine: NOISE_COLORS_BODY, colorLightFine: NOISE_LIGHT_BODY, colorLarge: NOISE_LARGE_BODY }; const mouthW = 7 * sf; const mouthH = 3 * sf; const mouthX = (16 * sf - mouthW) / 2; const mouthY = 10 * sf; const frontFaceMarkings = [ { x: mouthX, y: mouthY, w: mouthW, h: mouthH, color: MOUTH_BG_COLOR, isMouthBg: true }, ]; const frontSigilData = [ ...createArcSigil(3*sf, 4*sf, 2*sf, Math.PI*1.1, Math.PI*1.9, 10, 1), ...createLineSigil(13*sf, 13*sf, 15*sf, 15*sf, 5, 1)]; const sideSigilData = [ ...createLineSigil(11*sf, 10*sf, 14*sf, 4*sf, 12, 1), ...createArcSigil(4*sf, 4*sf, 1.5*sf, 0, Math.PI*0.8, 8, 1)]; const topSigilData = [ ...createArcSigil(8*sf, 8*sf, 5*sf, Math.PI*0.2, Math.PI*0.8, 15, 1), ...createLineSigil(2*sf, 2*sf, 14*sf, 14*sf, 20, 1)]; const hornNoiseParams = { countFine: 150, countLarge: 20, colorsFine: HORN_NOISE_VARIANTS, colorLightFine: HORN_NOISE_LIGHT, colorLarge: HORN_COLOR }; const hornSigilData = [ ...createArcSigil(2*sf, 8*sf, 1.5*sf, Math.PI*0.5, Math.PI*1.5, 8, 0.5) ]; const tentacleNoiseParams = { countFine: 200, countLarge: 25, colorsFine: TENTACLE_NOISE_VARIANTS, colorLightFine: TENTACLE_NOISE_LIGHT, colorLarge: TENTACLE_COLOR_BASE };
        const frontTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, BASE_COLOR, bodyNoiseParams, frontFaceMarkings, [], frontSigilData); const sideTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, BASE_COLOR, bodyNoiseParams, [], [], sideSigilData); const topTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, BASE_COLOR, bodyNoiseParams, [], [], topSigilData); const bottomTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, BASE_COLOR, { ...bodyNoiseParams, countFine: bodyNoiseParams.countFine - 100 }, [], [], [], 0.02); const backTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, BASE_COLOR, bodyNoiseParams, [], [], sideSigilData); const hornTextures = createHyperGhastTextures(TEXTURE_RESOLUTION, TEXTURE_RESOLUTION, HORN_COLOR, hornNoiseParams, [], [], hornSigilData, 0); const tentacleTextureData = createHyperGhastTextures(TEXTURE_RESOLUTION / 2, TEXTURE_RESOLUTION / 2, TENTACLE_COLOR_BASE, tentacleNoiseParams,[],[],[],0);
        const physicalMaterialProps = { roughness: 0.75, metalness: 0.0, clearcoat: 0.2, clearcoatRoughness: 0.3, transmission: 0.0, bumpScale: BUMP_SCALE }; function createGhastPhysicalMaterial(textures, intensity) { return new THREE.MeshPhysicalMaterial({ map: textures.texture, emissiveMap: textures.emissiveTexture, emissive: EMISSIVE_COLOR, emissiveIntensity: intensity, bumpMap: textures.emissiveTexture, ...physicalMaterialProps }); } const frontMaterial = createGhastPhysicalMaterial(frontTextures, SIGIL_EMISSIVE_INTENSITY_BASE); const sigilIntensity = SIGIL_EMISSIVE_INTENSITY_BASE; const bodyMaterials = [ createGhastPhysicalMaterial(sideTextures, sigilIntensity), createGhastPhysicalMaterial(sideTextures, sigilIntensity), createGhastPhysicalMaterial(topTextures, sigilIntensity), createGhastPhysicalMaterial(bottomTextures, 0), frontMaterial, createGhastPhysicalMaterial(backTextures, sigilIntensity),]; const hornMaterial = new THREE.MeshStandardMaterial({ map: hornTextures.texture, emissiveMap: hornTextures.emissiveTexture, emissive: EMISSIVE_COLOR, emissiveIntensity: HORN_SIGIL_EMISSIVE_INTENSITY_BASE, bumpMap: hornTextures.emissiveTexture, bumpScale: BUMP_SCALE * 1.5, roughness: 0.65, metalness: 0.1 }); const tentacleMaterial = new THREE.MeshStandardMaterial({ map: tentacleTextureData.texture, roughness: 0.85, metalness: 0.0 }); const tentacleTipMaterial = new THREE.MeshStandardMaterial({ color: TENTACLE_TIP_COLOR, roughness: 0.5, metalness: 0.1 });
        const geometricFaceCoreMaterial = new THREE.MeshStandardMaterial({ color: FACE_CORE_BASE_COLOR_HEX, emissive: RED_GLOW_COLOR_HEX, emissiveIntensity: FACE_CORE_EMISSIVE_INTENSITY, roughness: 0.8, metalness: 0.0 }); const geometricFaceHaloMaterial = new THREE.MeshBasicMaterial({ color: RED_GLOW_COLOR_HEX, transparent: true, opacity: HALO_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide }); const fireballCoreMaterial = new THREE.MeshStandardMaterial({ color: FACE_CORE_BASE_COLOR_HEX, emissive: RED_GLOW_COLOR_HEX, emissiveIntensity: FIREBALL_CORE_EMISSIVE_INTENSITY, roughness: 0.9, metalness: 0.0 }); const fireballHaloMaterial = new THREE.MeshBasicMaterial({ color: RED_GLOW_COLOR_HEX, transparent: true, opacity: FIREBALL_HALO_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false });
        this.pulsatingMaterials = [ { material: geometricFaceHaloMaterial, baseValue: HALO_OPACITY, property: 'opacity' } ];
        const bodyGeo = new THREE.BoxGeometry(BODY_SIZE, BODY_SIZE, BODY_SIZE); const tentacleBaseGeo = new THREE.BoxGeometry(TENTACLE_WIDTH, TENTACLE_HEIGHT, TENTACLE_WIDTH); const tentacleTipGeo = new THREE.ConeGeometry(TENTACLE_WIDTH * 0.6, TENTACLE_WIDTH * 1.2, 4); const fireballCoreGeo = new THREE.SphereGeometry(FIREBALL_CORE_SIZE, 6, 4); const fireballHaloGeo = new THREE.SphereGeometry(FIREBALL_HALO_SIZE, 8, 6);
        function createCurvedHorn(material) { const hornGroup = new THREE.Group(); hornGroup.name = "HornGroup"; let currentWidth = HORN_BASE_WIDTH; let currentDepth = HORN_BASE_DEPTH; let currentY = 0; for (let i = 0; i < HORN_SEGMENTS; i++) { const segmentGeo = new THREE.BoxGeometry(currentWidth, HORN_SEGMENT_HEIGHT, currentDepth); const segmentMesh = new THREE.Mesh(segmentGeo, material); segmentMesh.position.y = currentY + HORN_SEGMENT_HEIGHT / 2; const xRot = HORN_CURVE_ANGLE * (i + 1) * 1.4 + (Math.random() - 0.5) * 0.1; const zRot = HORN_CURVE_ANGLE * (i + 1) * 0.7 + HORN_TWIST_ANGLE * (i + Math.random()*2) + (Math.random() - 0.5) * 0.15; segmentMesh.rotation.x = xRot; segmentMesh.rotation.z = zRot; segmentMesh.rotation.y = (Math.random() - 0.5) * 0.1; segmentMesh.position.y -= Math.sin(xRot) * HORN_SEGMENT_HEIGHT * 0.5; segmentMesh.position.z += Math.sin(xRot) * HORN_SEGMENT_HEIGHT * 0.5; currentWidth *= HORN_TAPER; currentDepth *= HORN_TAPER; currentY += Math.cos(xRot) * HORN_SEGMENT_HEIGHT; segmentMesh.castShadow = false; hornGroup.add(segmentMesh); } return hornGroup; }
        this.bodyYOffset = TENTACLE_HEIGHT / 2 + 1; const bodyYOffset = this.bodyYOffset;
        const tentacleGroup = new THREE.Group(); tentacleGroup.name = "TentacleGroup"; this.mesh.add(tentacleGroup); const body = new THREE.Mesh(bodyGeo, bodyMaterials); body.position.y = bodyYOffset; body.name = "GhastBody"; body.castShadow = false; body.receiveShadow = true; this.mesh.add(body);
        const faceZOffset = BODY_SIZE / 2 + 0.01; const haloZOffset = BODY_SIZE / 2 + 0.02; const eyeWidth = 2.2; const eyeHeight = 0.8; const eyeDepth = 0.6; const eyeYPos = bodyYOffset + 1.5; const eyeXOffset = 2.5; const eyeAngle = Math.PI / 12; const eyeGeoCore = new THREE.BoxGeometry(eyeWidth, eyeHeight, eyeDepth); const eyeGeoHalo = new THREE.BoxGeometry(eyeWidth * HALO_SCALE, eyeHeight * HALO_SCALE, eyeDepth * HALO_SCALE); const leftEyeCore = new THREE.Mesh(eyeGeoCore, geometricFaceCoreMaterial); leftEyeCore.position.set(-eyeXOffset, eyeYPos, faceZOffset); leftEyeCore.rotation.z = eyeAngle; leftEyeCore.castShadow = false; this.mesh.add(leftEyeCore); const leftEyeHalo = new THREE.Mesh(eyeGeoHalo, geometricFaceHaloMaterial); leftEyeHalo.position.set(-eyeXOffset, eyeYPos, haloZOffset); leftEyeHalo.rotation.z = eyeAngle; this.mesh.add(leftEyeHalo); const rightEyeCore = new THREE.Mesh(eyeGeoCore, geometricFaceCoreMaterial); rightEyeCore.position.set(eyeXOffset, eyeYPos, faceZOffset); rightEyeCore.rotation.z = -eyeAngle; rightEyeCore.castShadow = false; this.mesh.add(rightEyeCore); const rightEyeHalo = new THREE.Mesh(eyeGeoHalo, geometricFaceHaloMaterial); rightEyeHalo.position.set(eyeXOffset, eyeYPos, haloZOffset); rightEyeHalo.rotation.z = -eyeAngle; this.mesh.add(rightEyeHalo); const fangWidth = 0.4; const fangHeight = 1.6; const fangDepth = 0.4; const fangYPos = bodyYOffset - 2.2; const numFangs = 7; const fangSpacing = 0.7; for (let i = 0; i < numFangs; i++) { const currentFangHeight = fangHeight * (0.7 + Math.random() * 0.6); const currentFangGeoCore = new THREE.BoxGeometry(fangWidth, currentFangHeight, fangDepth); const currentFangGeoHalo = new THREE.BoxGeometry(fangWidth * HALO_SCALE * 0.9, currentFangHeight * HALO_SCALE, fangDepth * HALO_SCALE * 0.9); const xPos = (i - (numFangs - 1) / 2) * fangSpacing; const yPos = fangYPos - (currentFangHeight - fangHeight) / 2; const fangCore = new THREE.Mesh(currentFangGeoCore, geometricFaceCoreMaterial); fangCore.position.set(xPos, yPos, faceZOffset); fangCore.castShadow = false; this.mesh.add(fangCore); const fangHalo = new THREE.Mesh(currentFangGeoHalo, geometricFaceHaloMaterial); fangHalo.position.set(xPos, yPos, haloZOffset); this.mesh.add(fangHalo); }
        const hornLeftGroup = createCurvedHorn(hornMaterial); hornLeftGroup.position.set( -HORN_SPACING_X, body.position.y + BODY_SIZE / 2 - 0.4, -BODY_SIZE / 2 + HORN_BASE_DEPTH * 0.6); hornLeftGroup.rotation.y = -Math.PI / 16 - 0.1; hornLeftGroup.rotation.z = Math.PI / 48; this.mesh.add(hornLeftGroup); const hornRightGroup = createCurvedHorn(hornMaterial); hornRightGroup.position.set( HORN_SPACING_X, body.position.y + BODY_SIZE / 2 - 0.4, -BODY_SIZE / 2 + HORN_BASE_DEPTH * 0.6); hornRightGroup.children.forEach(segment => { segment.rotation.z *= -1; }); hornRightGroup.rotation.y = Math.PI / 16 + 0.1; hornRightGroup.rotation.z = -Math.PI / 48; this.mesh.add(hornRightGroup);
        const tentaclePositions = []; for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { tentaclePositions.push({ x: i * TENTACLE_SPACING, z: j * TENTACLE_SPACING }); } } const varyHeight = true; const minTentacleHeightFactor = 0.8; tentaclePositions.forEach((pos, index) => { let currentTentacleHeight = TENTACLE_HEIGHT; let currentTentacleGeo = tentacleBaseGeo.clone(); if (varyHeight) { currentTentacleHeight = TENTACLE_HEIGHT * (minTentacleHeightFactor + Math.random() * (1.0 - minTentacleHeightFactor)); currentTentacleGeo = new THREE.BoxGeometry(TENTACLE_WIDTH, currentTentacleHeight, TENTACLE_WIDTH); } const tentacle = new THREE.Mesh(currentTentacleGeo, tentacleMaterial); const baseX = pos.x; const baseZ = pos.z; const baseY = body.position.y - BODY_SIZE / 2 - currentTentacleHeight / 2; tentacle.position.set(baseX, baseY, baseZ); tentacle.castShadow = true; tentacle.userData = { originalX: baseX, originalY: baseY, originalZ: baseZ, index: index, swaySpeedMult: 0.8 + Math.random() * 0.4, swayAmountMult: 0.8 + Math.random() * 0.4, swayPhaseOffset: Math.random() * Math.PI * 2 }; const tip = new THREE.Mesh(tentacleTipGeo, tentacleTipMaterial); tip.position.y = -currentTentacleHeight / 2 - (TENTACLE_WIDTH * 1.2) / 2 + 0.1; tip.rotation.x = Math.PI; tentacle.add(tip); tentacleGroup.add(tentacle); });
        this.particleGeometry = new THREE.BufferGeometry(); const particlePositions = new Float32Array(PARTICLE_COUNT * 3); const particleAlphas = new Float32Array(PARTICLE_COUNT); this.particleLifetimes = new Float32Array(PARTICLE_COUNT); this.particleVelocities = []; const particleColor = new THREE.Color(EMISSIVE_COLOR); for (let i = 0; i < PARTICLE_COUNT; i++) { particlePositions[i * 3] = 0; particlePositions[i * 3 + 1] = -100; particlePositions[i * 3 + 2] = 0; particleAlphas[i] = 0.0; this.particleLifetimes[i] = 0.0; this.particleVelocities[i] = new THREE.Vector3(); } this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3)); this.particleGeometry.setAttribute('alpha', new THREE.BufferAttribute(particleAlphas, 1)); const pCanvas = document.createElement('canvas'); pCanvas.width=16; pCanvas.height=16; const pCtx = pCanvas.getContext('2d'); pCtx.fillStyle='#fff'; pCtx.beginPath(); pCtx.arc(8,8,7,0,Math.PI*2); pCtx.fill(); const particleTexture = new THREE.CanvasTexture(pCanvas); const particleMaterial = new THREE.PointsMaterial({ size: PARTICLE_SIZE, map: particleTexture, color: particleColor, blending: THREE.AdditiveBlending, transparent: true, opacity: 1.0, depthWrite: false, sizeAttenuation: true }); this.particles = new THREE.Points(this.particleGeometry, particleMaterial); this.particles.name = "GhastParticles"; this.mesh.add(this.particles); const approxHornTotalHeight = HORN_SEGMENT_HEIGHT * HORN_SEGMENTS; this.particleSources = [ new THREE.Vector3(0, bodyYOffset + 1, BODY_SIZE / 2 + 0.5), new THREE.Vector3(-HORN_SPACING_X, bodyYOffset + BODY_SIZE / 2 + approxHornTotalHeight * 0.6, -BODY_SIZE/2 + HORN_BASE_DEPTH * 0.6), new THREE.Vector3( HORN_SPACING_X, bodyYOffset + BODY_SIZE / 2 + approxHornTotalHeight * 0.6, -BODY_SIZE/2 + HORN_BASE_DEPTH * 0.6), ];
        this.fireballGroup = new THREE.Group(); this.fireballGroup.name = "FireballSwarm"; const fireballOrbitCenter = new THREE.Vector3(0, bodyYOffset, 0); for (let i = 0; i < FIREBALL_COUNT; i++) { const fireballContainer = new THREE.Group(); const fireballCore = new THREE.Mesh(fireballCoreGeo, fireballCoreMaterial); fireballContainer.add(fireballCore); const fireballHalo = new THREE.Mesh(fireballHaloGeo, fireballHaloMaterial); fireballContainer.add(fireballHalo); const radius = MathUtils.randFloat(FIREBALL_ORBIT_RADIUS_MIN, FIREBALL_ORBIT_RADIUS_MAX); const phi = Math.acos(-1 + (2 * Math.random())); const theta = Math.random() * Math.PI * 2; fireballContainer.position.setFromSphericalCoords(radius, phi, theta); fireballContainer.position.add(fireballOrbitCenter); fireballContainer.userData = { noiseSeedX: Math.random() * 100, noiseSeedY: Math.random() * 100, noiseSeedZ: Math.random() * 100, initialRelativePosition: fireballContainer.position.clone().sub(fireballOrbitCenter) }; this.fireballGroup.add(fireballContainer); } this.mesh.add(this.fireballGroup);
        const cylinderGeo = new THREE.CylinderGeometry(this.cylinderRadius, this.cylinderRadius, this.cylinderHeight, 16, 1, true); const cylinderMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.3, depthWrite: false }); this.collisionCylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat); this.collisionCylinderMesh.name = "GhastCollisionCylinder"; this.collisionCylinderMesh.position.set(0, 0, 0); this.collisionCylinderMesh.visible = this.showCollisionCylinder; this.mesh.add(this.collisionCylinderMesh);
    }

    // updateLogic(deltaTime, player, activeFireballs) { // OLD Signature
    updateLogic(deltaTime, player, fireballsArray) { // NEW Signature (pass internal fireballs)
        if (this.isDead) return;
        const time = this.clock.getElapsedTime();

        if (this.attackCooldownTimer > 0) { this.attackCooldownTimer -= deltaTime; }

        this.isAttackingOrCoolingDown = false; this.currentTarget = null;
        if (player && !player.isDead) {
            const distanceSq = this.position.distanceToSquared(player.position);
            const territory = this.movementController.territory;
            const playerInTerritory = player.position.x >= territory.minX && player.position.x <= territory.maxX && player.position.z >= territory.minZ && player.position.z <= territory.maxZ;
            if (playerInTerritory && distanceSq < this.attackRangeSq) {
                this.currentTarget = player; this.isAttackingOrCoolingDown = true;
                if (this.attackCooldownTimer <= 0) {
                    this.fireFireball(player); // Call updated method
                    this.attackCooldownTimer = this.fireballCooldown;
                }
            }
        }

        if (this.movementController) { this.movementController.update(deltaTime, player); }

        // --- Internal Animations ---
        const TENTACLE_SWAY_SPEED = 1.9; const TENTACLE_SWAY_AMOUNT = 0.5; const TENTACLE_ROT_AMOUNT = 0.07; const TENTACLE_JITTER_AMOUNT = 0.15; const BODY_BREATHE_SPEED = 0.9; const BODY_BREATHE_AMOUNT = 0.015; const GLOW_PULSATION_SPEED = 1.8; const GLOW_PULSATION_AMOUNT = 0.6; const PARTICLE_SPAWN_RATE = 150; const PARTICLE_LIFETIME = 1.1; const PARTICLE_INITIAL_VELOCITY = 1.4; const PARTICLE_DRAG = 0.97; const PARTICLE_COUNT = 250; const HALO_OPACITY = 0.55; const FIREBALL_HALO_OPACITY = 0.7; const TWITCH_FREQUENCY_MIN = 0.3; const TWITCH_FREQUENCY_MAX = 0.9; const TWITCH_MOVE_AMOUNT = 0.35; const TWITCH_ROT_AMOUNT = Math.PI / 48; const FIREBALL_NOISE_AMOUNT = 1.2; const FIREBALL_NOISE_SPEED = 0.9; const FIREBALL_SYSTEM_ROTATION_SPEED = 0.4; const BODY_SIZE = 9; const FIREBALL_VERTICAL_SPREAD = BODY_SIZE * 0.5;
        const creatureGroup = this.mesh; const body = creatureGroup.getObjectByName("GhastBody"); const tentacleGroup = creatureGroup.getObjectByName("TentacleGroup"); const childGroups = creatureGroup.children.filter(c => c.isGroup && c !== tentacleGroup && c !== this.particles && c !== body && !c.geometry && c !== this.fireballGroup && c !== this.collisionCylinderMesh); const hornLeftGroup = childGroups.find(g => g.position.x < 0); const hornRightGroup = childGroups.find(g => g.position.x > 0);
        this.timeUntilTwitch -= deltaTime; if (this.timeUntilTwitch <= 0 && this.twitchTimer <= 0) { this.twitchTimer = this.twitchDuration; this.twitchOffset.set( (Math.random() - 0.5) * TWITCH_MOVE_AMOUNT, (Math.random() - 0.5) * TWITCH_MOVE_AMOUNT * 0.5, (Math.random() - 0.5) * TWITCH_MOVE_AMOUNT ); this.twitchRotOffset.set( (Math.random() - 0.5) * TWITCH_ROT_AMOUNT, (Math.random() - 0.5) * TWITCH_ROT_AMOUNT, (Math.random() - 0.5) * TWITCH_ROT_AMOUNT ); } let currentTwitchFactor = 0; if (this.twitchTimer > 0) { this.twitchTimer -= deltaTime; currentTwitchFactor = Math.sin((1.0 - this.twitchTimer / this.twitchDuration) * Math.PI); if (this.twitchTimer <= 0) { this.twitchTimer = 0; this.timeUntilTwitch = TWITCH_FREQUENCY_MIN + Math.random() * (TWITCH_FREQUENCY_MAX - TWITCH_FREQUENCY_MIN); this.twitchOffset.set(0,0,0); this.twitchRotOffset.set(0,0,0); currentTwitchFactor = 0; } }
        if (body) { const breatheFactor = Math.sin(time * BODY_BREATHE_SPEED) * BODY_BREATHE_AMOUNT; body.scale.set(1 + breatheFactor, 1 + breatheFactor, 1 + breatheFactor); body.position.y = this.bodyYOffset + this.twitchOffset.y * currentTwitchFactor; }
        creatureGroup.rotation.x += this.twitchRotOffset.x * currentTwitchFactor; creatureGroup.rotation.z += this.twitchRotOffset.z * currentTwitchFactor;
        if (hornLeftGroup) { hornLeftGroup.rotation.x = creatureGroup.rotation.x * 0.3; hornLeftGroup.rotation.z = creatureGroup.rotation.z * 0.3 + Math.PI / 48; } if (hornRightGroup) { hornRightGroup.rotation.x = creatureGroup.rotation.x * 0.3; hornRightGroup.rotation.z = creatureGroup.rotation.z * 0.3 - Math.PI / 48; }
        if (tentacleGroup) { tentacleGroup.children.forEach(tentacle => { const { originalX, originalY, originalZ, index, swaySpeedMult, swayAmountMult, swayPhaseOffset } = tentacle.userData; const swayOffset = time * TENTACLE_SWAY_SPEED * swaySpeedMult + swayPhaseOffset + index * 0.3; const currentSwayAmount = TENTACLE_SWAY_AMOUNT * swayAmountMult; const jitterX = (Math.random() - 0.5) * TENTACLE_JITTER_AMOUNT; const jitterZ = (Math.random() - 0.5) * TENTACLE_JITTER_AMOUNT; tentacle.position.x = originalX + Math.sin(swayOffset) * currentSwayAmount + jitterX; tentacle.position.z = originalZ + Math.cos(swayOffset * 0.8) * currentSwayAmount * 0.7 + jitterZ; tentacle.position.y = originalY; tentacle.rotation.y = Math.sin(swayOffset * 0.5) * TENTACLE_ROT_AMOUNT + jitterX * 0.1; tentacle.rotation.x = Math.cos(swayOffset * 0.6) * TENTACLE_ROT_AMOUNT * 0.5 + jitterZ * 0.1; }); }
        const pulseFactor = (Math.sin(time * GLOW_PULSATION_SPEED) + 1) / 2; this.pulsatingMaterials.forEach((pulseData) => { const { material, baseValue, property } = pulseData; if (material && typeof baseValue === 'number' && property) { material[property] = baseValue * (1.0 - GLOW_PULSATION_AMOUNT + pulseFactor * GLOW_PULSATION_AMOUNT * 2); } });
        if (this.fireballGroup) { const orbitCenter = new THREE.Vector3(0, this.bodyYOffset, 0); this.fireballGroup.children.forEach(fireballContainer => { const data = fireballContainer.userData; const noiseTime = time * FIREBALL_NOISE_SPEED; const noiseX = (MathUtils.seededRandom(data.noiseSeedX + noiseTime) - 0.5) * FIREBALL_NOISE_AMOUNT; const noiseY = (MathUtils.seededRandom(data.noiseSeedY + noiseTime) - 0.5) * FIREBALL_NOISE_AMOUNT; const noiseZ = (MathUtils.seededRandom(data.noiseSeedZ + noiseTime) - 0.5) * FIREBALL_NOISE_AMOUNT; fireballContainer.position.copy(data.initialRelativePosition).add(new THREE.Vector3(noiseX, noiseY, noiseZ)); }); this.fireballGroup.position.copy(orbitCenter); this.fireballGroup.rotation.y += FIREBALL_SYSTEM_ROTATION_SPEED * deltaTime; this.fireballGroup.rotation.x += FIREBALL_SYSTEM_ROTATION_SPEED * 0.4 * deltaTime; this.fireballGroup.rotation.z -= FIREBALL_SYSTEM_ROTATION_SPEED * 0.2 * deltaTime; this.fireballGroup.position.sub(orbitCenter); }
        if (this.particles && this.particleGeometry) { this.particlesToSpawn += PARTICLE_SPAWN_RATE * deltaTime; const posAttribute = this.particleGeometry.attributes.position; const alphaAttribute = this.particleGeometry.attributes.alpha; let spawnCount = Math.floor(this.particlesToSpawn); this.particlesToSpawn -= spawnCount; let nextAvailableParticleIndex = 0; const _tempVec = new THREE.Vector3(); for (let i = 0; i < PARTICLE_COUNT; i++) { if (this.particleLifetimes[i] > 0) { this.particleLifetimes[i] -= deltaTime; if (this.particleLifetimes[i] <= 0) { alphaAttribute.setX(i, 0); this.particleLifetimes[i] = 0; } else { this.particleVelocities[i].multiplyScalar(PARTICLE_DRAG); this.particleVelocities[i].y += 0.5 * deltaTime; posAttribute.setXYZ( i, posAttribute.getX(i) + this.particleVelocities[i].x * deltaTime, posAttribute.getY(i) + this.particleVelocities[i].y * deltaTime, posAttribute.getZ(i) + this.particleVelocities[i].z * deltaTime ); alphaAttribute.setX(i, Math.max(0, (this.particleLifetimes[i] / PARTICLE_LIFETIME))); } } else if (spawnCount > 0 && nextAvailableParticleIndex <= i) { const particleIndex = i; spawnCount--; nextAvailableParticleIndex = i + 1; const sourceIndex = Math.floor(Math.random() * this.particleSources.length); const sourcePosLocal = this.particleSources[sourceIndex].clone(); sourcePosLocal.add(new THREE.Vector3( (Math.random() - 0.5) * 1.8, (Math.random() - 0.5) * 1.8, (Math.random() - 0.5) * 1.8 )); const sourcePosWorld = _tempVec.copy(sourcePosLocal).applyMatrix4(this.mesh.matrixWorld); posAttribute.setXYZ(particleIndex, sourcePosWorld.x, sourcePosWorld.y, sourcePosWorld.z); alphaAttribute.setX(particleIndex, 1.0); this.particleLifetimes[particleIndex] = PARTICLE_LIFETIME * (0.7 + Math.random() * 0.6); const velocity = new THREE.Vector3( (Math.random() - 0.5), Math.random() * 0.6 + 0.1, (Math.random() - 0.5) ); velocity.normalize().multiplyScalar(PARTICLE_INITIAL_VELOCITY * (0.6 + Math.random() * 0.8)); this.particleVelocities[particleIndex].copy(velocity); } } posAttribute.needsUpdate = true; alphaAttribute.needsUpdate = true; }

        this.visualPosition.copy(this.position);
        if (this.collisionCylinderMesh) { this.collisionCylinderMesh.visible = this.showCollisionCylinder; }
    }

    // --- Method to fire a fireball ---
    fireFireball(player) { // <<<--- Updated Signature
        if (!player || this.isDead) return;
        if (!this.entityManager) { console.error("EntityManager missing in Ghast."); return; }

        const body = this.mesh.getObjectByName("GhastBody");
        const startOffset = new THREE.Vector3(0, 0, 1);
        if (body) { startOffset.applyQuaternion(this.mesh.quaternion); } // Use main mesh quaternion
        startOffset.multiplyScalar(this.cylinderRadius * 0.6);
        const startPos = this.position.clone().add(startOffset);
        startPos.y += this.bodyYOffset * 0.5;

        const direction = new THREE.Vector3().subVectors(player.position, startPos).normalize();

        const fireball = new Fireball( this.scene, startPos, direction, this.fireballSpeed, this.fireballDamage, this.fireballLifetime, this );

        this.entityManager.addFireball(fireball); // <<<--- Use EntityManager

        // TODO: Play sound
        console.log("Ghast fired fireball!");
    }

    takeDamage(amount) {
        if (this.isDead) return; this.health -= amount; console.log(`Ghast took ${amount} damage, health: ${this.health}`); if (this.health <= 0) { this.die(); }
    }

    die() {
        if (this.isDead) return; console.log("Scary Ghast died!"); this.isDead = true; let fadeDuration = 1.0; let fadeTimer = 0; this.mesh.traverse(child => { if (child.material) { const materials = Array.isArray(child.material) ? child.material : [child.material]; materials.forEach(m => { m.transparent = true; m.depthWrite = false; }); } }); const fadeInterval = setInterval(() => { fadeTimer += 0.05; const opacity = Math.max(0, 1.0 - fadeTimer / fadeDuration); this.mesh.traverse(child => { if (child.material) { const materials = Array.isArray(child.material) ? child.material : [child.material]; materials.forEach(m => m.opacity = opacity); } }); if (opacity <= 0) { clearInterval(fadeInterval); if (this.mesh.parent) this.mesh.parent.remove(this.mesh); this.mesh.traverse(child => { if (child.geometry) child.geometry.dispose(); if (child.material) { const materials = Array.isArray(child.material) ? child.material : [child.material]; materials.forEach(m => m.dispose()); } }); if (this.particleGeometry) this.particleGeometry.dispose(); this.mesh = null; } }, 50);
    }
}
// --- END OF FILE Ghast.js ---